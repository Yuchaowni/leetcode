# 53 人生的巅峰和当下的选择

这是一道非常经典的dynamic programming的题: https://leetcode.com/problems/maximum-subarray/

如果没有找到其中的奥妙, 往往会觉得无从下手. 

诀窍在于用一个中间变量 cur 保存一个当前序列的局部最大值, 如果 cur 小于0, 那就没有必要续存, 直接换手头的变量作为新的序列. 然后把这个局部最大值和全域最大值 res 比较, 留下最大的那个.

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = INT_MIN, cur = 0;
        for (int num:nums){
            cur = cur>0? cur+num : num;
            res = max(res,cur);
        }
        return res;
    }
};
```

所谓人生要学会做减法, 也就是当目前的局域累计值是负的时候, 就要坚决地把这个序列丢掉, 开启一个新的序列, 因为不管新序列多差, 也不会比这个更差了. 也许你的未来不会有新的巅峰, 但这个是你可能有的最好的策略.

# 136 一种价值观叫做我就是跟你不一样

找出那个独一无二的数/单身狗. 最快的解法是用 XOR, 不同的就是 true.

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        for (int i=1; i!=nums.size();i++)
            nums[0] ^= nums[i];
        return nums[0];
    }
};
```

# 2 梦想只是一个指针, 你有了价值才有空间

用 linked list 来实现加法

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode prehead(0);
        ListNode *l= &prehead;
        int lead = 0;
        while (l1 || l2 ||lead){
            int v = 0;
            if (l1) {
                v +=l1->val;
                l1 = l1->next;
            }
            if (l2) {
                v +=l2->val;
                l2 = l2->next;
            }
            if (lead) v += lead;
            l->next = new ListNode(v%10);
            lead = v / 10;
            l = l->next;
        }
        return prehead.next;
    }
};
```

